# XCore407I Remora Firmware

Production-ready firmware for the STM32F407 (XCore407I) implementing:

- 168 MHz system clock (PLL from 8 MHz HSE)
- STM32CubeF4 HAL (minimal modules: RCC, GPIO, ETH, DMA, TIM, FLASH, PWR, CORTEX)
- RMII Ethernet (DP83848 or compatible PHY) with lwIP (NO_SYS=1)
- Remora UDP protocol (port 27181) with unicast feedback & sequence gap detection
- Motion control hooks (step generator + encoder feedback)
- Diagnostics counters (Ethernet RX, link events, Remora sequence gaps)
- Complete newlib syscall stubs

## Directory Highlights

- `targets/TARGET_XCORE407I/` – Target specific build, linker script, port glue
- `Remora-OS6/Firmware/.../lwip/` – Network interface (`ethernetif.c`), Remora UDP (`remora_udp.c`)
- `st/hal_conf/stm32f4xx_hal_conf.h` – Pruned HAL configuration
- `syscalls.c` – Minimal libc syscalls

## Build

Requires `arm-none-eabi-gcc`, CMake, and Make.

```bash
mkdir -p targets/TARGET_XCORE407I/build
cd targets/TARGET_XCORE407I/build
cmake -DCMAKE_BUILD_TYPE=Release ..
make -j$(nproc)
```text

Resulting artifacts:

- ELF: `XCORE407I_FIRMWARE`
- Binary: `XCORE407I_FIRMWARE.bin`
- Map: `XCORE407I_FIRMWARE.map`

### Build Options

Key CMake cache options (defaults shown):

| Option | Default | Effect |
|--------|---------|--------|
| `USE_PG11_TXEN` | `OFF` | `OFF` => TX_EN on `PB11` (schematic). `ON` => legacy ref-design routing to `PG11`. |
| `ETH_HW_CHECKSUM` | `OFF` | Enable hardware checksum offload (requires matching lwIP opts to disable soft sums). |
| `USE_ABSTRACT_DRIVERS` | `OFF` | Enable optional GPIO/QEI abstraction layer. |
| `ENABLE_QEI_DIAG` | `OFF` | Periodic encoder diag log when abstractions enabled. |
| `BOARD_ENABLE_ETH` | `ON` | Include RMII Ethernet bring-up. |
| `BOARD_ENABLE_ULPI` | `OFF` | Enable USB HS ULPI (conflicts with Ethernet TX pins). |
| `BOARD_ENABLE_NAND` | `OFF` | Enable NAND (FSMC) mapping (will warn on pin conflicts). |
| `BOARD_ENABLE_SDIO` | `OFF` | Reserve SDIO (PC8–PC12, PD2). |
| `MOTION_PROFILE_FSMC_SAFE` | `OFF` | Remap motion ENA/ALM/E‑Stop/Probe away from FSMC/SDIO (see Pin Mapping). |
| `MOTION_PROFILE_SDIO_SAFE` | `OFF` | Keep SDIO lines free (no remap; prefers SDIO over full alarm exposure). |

Example enabling hardware checksum and ULPI disabled (default), forcing legacy TX_EN on PG11:

```bash
cmake -DUSE_PG11_TXEN=ON -DETH_HW_CHECKSUM=ON -DCMAKE_BUILD_TYPE=Release ..
```

Example enabling NAND with safe motion remap:

```bash
cmake -DBOARD_ENABLE_NAND=ON -DMOTION_PROFILE_FSMC_SAFE=ON -DCMAKE_BUILD_TYPE=Release ..
```

Example enabling SDIO preserving its pins:

```bash
cmake -DBOARD_ENABLE_SDIO=ON -DMOTION_PROFILE_SDIO_SAFE=ON -DCMAKE_BUILD_TYPE=Release ..
```

The firmware logs (UART) the active TX_EN pin and whether forced / fallback network modes are entered.

## Abstract Driver Layer (Optional)

An optional set of light-weight abstractions is available to reduce direct dependency on STM32 HAL calls and ease future multi-target unification:

Components (when `-DUSE_ABSTRACT_DRIVERS=ON`):

- `drivers/pin/` – Wrapper around GPIO providing simple `pin_init`, `pin_write`, `pin_read`, `pin_toggle` with strongly typed mode helpers.
- `drivers/qei/` – Minimal quadrature encoder timer wrapper accumulating position with rollover handling (`qei_init`, `qei_get_position`).
- `drivers/drivers_init.*` – Single entry to initialize enabled driver abstractions.
- `drivers/comms/` – Placeholder skeleton for future Remora communications decoupling (currently stats & stubs only).

Rationale:

- Enables sharing higher-level motion / feedback code with other Remora targets that already use an abstraction layer.
- Provides a contained migration path: modules can be ported one by one (e.g. replace direct `HAL_GPIO_WritePin` calls in step generation logic).
- Keeps zero overhead when disabled (files not compiled, no extra includes).

Next integration steps (roadmap):

1. Wrap existing `encoder.c` logic with `#ifdef USE_ABSTRACT_DRIVERS` to fetch counts via `qei_get_position`.
2. Introduce a comms abstraction (future) if protocol variants diverge.
3. Extend `pin` helper with alternate-function config to unify timer / encoder pin setup.
4. Leverage new velocity helper (`qei_update_velocity` / `qei_get_velocity`) for motion control loops.

See `targets/TARGET_XCORE407I/drivers/README.md` for detailed guidance and extension ideas.

### Schematic Reference & Pin Validation

Schematics are located under `resources/schematic/xcore407i schematic/`. Cross-check critical nets:

- Ethernet RMII: Ensure TXD0/TXD1 (PB12/PB13) not repurposed; they conflict with potential ULPI.
- Encoder Channels: TIM3 (PB4/PB5), TIM1 (PA8/PA9), TIM2 (PA15/PB3) – verify jumpers / headers populated.
- Heartbeat / LEDs: If your board variant lacks PD12–PD15 LEDs, the early diagnostic blink just exercises those pins harmlessly.
- PROBE (PG0) and E-Stop (PE4) lines should have appropriate pull-ups populated; check for series resistors or inversion circuitry.
- Alarm inputs (PE0..PE3) must be routed to drivers’ ALM signals with proper polarity matching (active low assumed).

If a schematic revision changes net assignments, update `board_xcore407i.h` plus the pin tables here to avoid doc drift.

### Pin Header (2x35) Mapping (Default Profiles)

The 70-pin 2x35 header exposes most primary motion, encoder and Ethernet signals. Some safety / jog lines remain internal by design. Mapping below correlates firmware logical roles to header pins (from schematic `Pin Port`).

#### 1. Stepper Axes (Default / SDIO-Safe)
| Axis | Function | MCU Pin | Header Pin | Notes |
|------|----------|---------|------------|-------|
| X | STEP | PB6 | 25 | TIM4_CH1 AF2 |
| X | DIR  | PB7 | 26 |  |
| X | ENA  | PD0 | 51 | Conflicts FSMC_D2 (NAND) |
| X | ALM  | PE0 | 67 | Not SDIO conflict; FSMC_NBL0 |
| Y | STEP | PB8 | 27 | TIM4_CH3 AF2 |
| Y | DIR  | PB9 | 28 |  |
| Y | ENA  | PD1 | 52 | Conflicts FSMC_D3 (NAND) |
| Y | ALM  | PE1 | 68 | FSMC_NBL1 |
| Z | STEP | PA6 | 9  | TIM3_CH1 |
| Z | DIR  | PB14| 33 | Shares ULPI_D7/OTG_HS_DM (ULPI disabled by default) |
| Z | ENA  | PD2 | 53 | SDIO_CMD (conflict if SDIO enabled) |
| Z | ALM  | PE2 | —  | Not on header (FSMC_A23) |
| A | STEP | PC6 | 41 | TIM8_CH1 / SDIO_D6 alt |
| A | DIR  | PC7 | 42 | TIM8_CH2 / SDIO_D7 alt |
| A | ENA  | PD3 | 54 | FSMC_CLK |
| A | ALM  | PE3 | —  | Not on header (FSMC_A19) |

#### 2. Stepper Axes (FSMC-Safe Profile)
When `MOTION_PROFILE_FSMC_SAFE=ON` ENA & ALM remapped to free FSMC/SDIO and expose all alarms:
| Axis | ENA Pin (Header) | ALM Pin (Header) | Notes |
|------|------------------|------------------|-------|
| X | PA4 (7) | PC10 (45) | Frees PD0 / PE0 |
| Y | PA15 (18)| PC11 (46) | Frees PD1 / PE1 |
| Z | PC8 (43) | PC12 (47) | Z ENA/ALM share SDIO lines (profile incompatible with SDIO) |
| A | PC9 (44) | PD8 (59)  |  |

#### 3. Encoders
| Encoder | Channel | MCU Pin | Header Pin | Notes |
|---------|---------|---------|------------|-------|
| Enc0 | CH1 | PB4 | 23 | TIM3_CH1 remap |
| Enc0 | CH2 | PB5 | 24 | TIM3_CH2 remap |
| Enc1 | CH1 | PA8 | 11 | TIM1_CH1 |
| Enc1 | CH2 | PA9 | 12 | TIM1_CH2 |
| Enc2 | CH1 | PA15| 18 | TIM2_CH1 (requires SWD only; JTAG disabled) |
| Enc2 | CH2 | PB3 | 22 | TIM2_CH2 |
| Enc3 | —   | —   | —  | Not wired |

#### 4. Safety / Probe / Jog (Default)
| Signal | MCU Pin | Header Pin | Notes |
|--------|---------|------------|-------|
| E-Stop | PE4 | — | Internal only (FSMC_A20) |
| Probe  | PG0 | — | Internal (FSMC_A10) |
| Jog +X/-X | PF0 / PF1 | — | Internal (FSMC_A0/A1) |
| Jog +Y/-Y | PF2 / PF3 | — | Internal |
| Jog +Z/-Z | PF4 / PF5 | — | Internal |
| Jog +A/-A | PF6 / PF7 | — | Internal |

#### 5. Safety / Probe (FSMC-Safe Remap)
| Signal | MCU Pin | Header Pin | Notes |
|--------|---------|------------|-------|
| E-Stop | PB2 | 21 | BOOT1 pin – ensure boot strap resistor correct |
| Probe  | PC8 | 43 | Shares with Z_ENA in FSMC-safe (choose usage) |

#### 6. Ethernet RMII
| Signal | MCU Pin | Header Pin | Notes |
|--------|---------|------------|-------|
| REF_CLK | PA1 | 4 | 50 MHz from PHY |
| MDIO | PA2 | 5 |  |
| CRS_DV | PA7 | 10 |  |
| MDC | PC1 | 36 |  |
| RXD0 | PC4 | 39 |  |
| RXD1 | PC5 | 40 |  |
| TX_EN | PB11 (default) | 30 | Set `USE_PG11_TXEN=ON` to relocate |
| TXD0 | PB12 | 31 |  Conflicts ULPI_D5 |
| TXD1 | PB13 | 32 |  Conflicts ULPI_D6 |

#### 7. Profile Selection Guidance
| Scenario | Recommended Profile | Rationale |
|----------|---------------------|-----------|
| Need NAND (FSMC) | `MOTION_PROFILE_FSMC_SAFE=ON` | Frees PD0/PD1 and exposes all ALM |
| Need SDIO (SD card) | `MOTION_PROFILE_SDIO_SAFE=ON` | Preserves PC8–PC12, PD2 |
| Need both NAND & SDIO | Custom (manual overrides) | Profiles conflict on resource usage |

Generate current CSV mapping (subset) with:
```bash
python3 scripts/gen_pin_map.py scripts/pin_map.csv
```

> NOTE: The CSV reflects default profile mapping. Add logic later for profile-based variants if needed.

### Automated Extraction (No Manual Duplication)

Two helper scripts keep documentation synchronized with the authoritative header `board_xcore407i.h`:

1. `scripts/extract_pin_map.py` – Parses the header conditionals and generates a minimal variant CSV:

  ```bash
  python3 scripts/extract_pin_map.py --out scripts/pin_map_extracted.csv
  ```

  Output columns: `Signal,Default,FSMC-Safe,SDIO-Safe` (MCU pins). This is a direct parse – if you change a define in the header, re-run to verify.

2. `scripts/gen_pin_map_profiles.py` – Higher-level table including 70‑pin header positions for each profile:

  ```bash
  python3 scripts/gen_pin_map_profiles.py
  ```

  Produces `scripts/pin_map_profiles.csv` (columns: Signal, Default MCU/Header, FSMC-Safe MCU/Header, SDIO-Safe MCU/Header).

3. `scripts/extract_full_pin_map.py` – Comprehensive map (motion + safety + encoders + ethernet) with category tags:

  ```bash
  python3 scripts/extract_full_pin_map.py --out scripts/pin_map_full.csv
  ```

  Columns: `Signal,Category,Default MCU,Default Header,FSMC-Safe MCU,FSMC-Safe Header,SDIO-Safe MCU,SDIO-Safe Header`.

Add these scripts to CI to fail the build if a diff is detected between committed CSV and regenerated output (prevents doc drift).

## Submodules

This project embeds the upstream `STM32CubeF4` distribution, which itself references many (≈56) Git submodules. They cover:

- Core device support (CMSIS device headers)
- HAL driver sources
- Board Support Packages (Nucleo, Discovery, Eval boards)
- Peripheral component drivers (sensors, codecs, Ethernet PHYs, displays, etc.)
- Middleware (FreeRTOS, LwIP, FatFs, USB Host/Device, mbedTLS, LibJPEG)

For a minimal build of this firmware you only need these submodules initialized:

- `Drivers/CMSIS/Device/ST/STM32F4xx`
- `Drivers/STM32F4xx_HAL_Driver`
- `Middlewares/Third_Party/LwIP`

All other submodules are optional unless you plan to enable their corresponding features.

### Clone With All Submodules

```bash
git clone --recurse-submodules <your_fork_url_or_origin>
```

If you already cloned without them:

```bash
git submodule update --init --recursive
```

### Initialize Only Required Submodules (Minimal Build)

From the repository root:

```bash
git submodule update --init st/STM32CubeF4/Drivers/CMSIS/Device/ST/STM32F4xx \
  st/STM32CubeF4/Drivers/STM32F4xx_HAL_Driver \
  st/STM32CubeF4/Middlewares/Third_Party/LwIP
```

You can add others later, for example FreeRTOS or FatFS:

```bash
git submodule update --init st/STM32CubeF4/Middlewares/Third_Party/FreeRTOS
git submodule update --init st/STM32CubeF4/Middlewares/Third_Party/FatFs
```

To update everything to the referenced commits:

```bash
git submodule update --remote --recursive
```

### Why So Many Submodules?

STMicroelectronics decomposes the ecosystem into granular repositories so each peripheral driver / middleware stack can evolve independently and be reused across device families. This avoids monolithic updates when only a component changes.

### IDE Notes

Some IDEs (VS Code, CLion, Eclipse) do not automatically index unopened submodule folders. If you need code completion for a specific middleware, open a file inside that submodule or add it to your workspace explicitly.

### Common Issues

| Symptom | Cause | Fix |
|---------|-------|-----|
| Missing `stm32f4xx_hal.h` | `STM32F4xx_HAL_Driver` submodule not initialized | Run minimal init command above |
| Undefined CMSIS symbols | CMSIS device submodule missing | Initialize `Drivers/CMSIS/Device/ST/STM32F4xx` |
| LwIP headers not found | LwIP submodule missing | Initialize `Middlewares/Third_Party/LwIP` |
| Build errors for USB / FatFS | Middleware not initialized | Init specific middleware or remove feature from build |

### Keeping Submodules Updated

To fetch the latest remote revisions (respecting the branches defined in `.gitmodules`):

```bash
git submodule update --remote --recursive
```

Lock a specific revision by committing the updated submodule SHA in the parent repository.

### Pruning Unused Submodules (Optional)

If storage is a concern, you can perform a sparse clone (Git 2.25+):

```bash
git clone --filter=blob:none --recurse-submodules <url>
```

Or remove unneeded working directories (NOT recommended if you may need updates later):

```bash
rm -rf st/STM32CubeF4/Middlewares/Third_Party/FreeRTOS
```

> Note: Removing a submodule folder without adjusting `.gitmodules` will cause `git status` to show modifications; prefer leaving them uninitialized instead of deleting.

### Quick Start Script & Extended Guide

For a streamlined minimal setup run:

```bash
./scripts/init_minimal_submodules.sh
```

See `SETUP.md` for a full onboarding walkthrough (toolchain prerequisites, build, flashing, troubleshooting).

## Jog Control Module

The jog system is modular (`jog.c` / `jog.h`) and provides per-axis acceleration ramps and telemetry.

API naming convention:

```c
void jog_init(void);
void jog_poll(void);
void jog_set_speed_axis(int axis, uint32_t steps_per_sec);
void jog_set_accel_axis(int axis, uint32_t steps_per_sec2);
void jog_set_speed(uint32_t steps_per_sec);   // applies to all axes
void jog_set_accel(uint32_t steps_per_sec2);  // applies to all axes
uint32_t jog_get_speed_axis(int axis);        // configured target
uint32_t jog_get_accel_axis(int axis);
uint32_t jog_get_current_speed_axis(int axis); // instantaneous ramped speed
```

Feedback telemetry now appends four `uint32_t` values (current per-axis jog speeds in steps/s) plus a `uint32_t` probe field at the end of the payload.

Feedback field order (after UDP header) – Protocol Version 4 (v2/v3 fields are prefix):

1. `jointFeedback[JOINTS]` (encoder counts)
2. `processVariable[JOINTS]`
3. `inputs` (legacy input bitfield)
4. `faultMask` (uint32)
5. `estop` (uint32, 0/1)
6. `jogSpeeds[4]` (current ramped speeds, steps/s)
7. `jogTargets[4]` (configured target speeds, steps/s)
8. `jogDirs[4]` (0 idle, 1 positive, 2 negative)
9. `probe` (uint32: 0 = triggered, 1 = not triggered)

### Protocol Version Negotiation

The `reserved` field in the UDP header carries `REMORA_PROTOCOL_VERSION` (currently `4`). A host must read this value before assuming the presence or ordering of extended fields (jogTargets, jogDirs, probe, firmwareVersion, buildHash, heartbeat, uptime, statusFlags, seqGapEvents, crc32). Hosts encountering an unexpected version should either:

1. Fallback to a prior known parsing layout, or
2. Reject the packet and request a firmware update / compatibility mode.

No backward compatibility shim is provided inside the firmware; version increments indicate a structural change in payload layout.

Example host unpack (pseudo-C) for Protocol Version 3:

```c
uint32_t *p = (uint32_t*)payload; // after header
int idx = 0;
int32_t *jointFeedback = (int32_t*)&p[idx]; idx += JOINTS; // if int32 counts
int32_t *processVar    = (int32_t*)&p[idx]; idx += JOINTS;
uint32_t inputs        = p[idx++];
uint32_t faultMask     = p[idx++];
uint32_t estop         = p[idx++];
uint32_t jogSpeed[4];
for(int a=0;a<4;++a) jogSpeed[a] = p[idx++];
uint32_t probe         = p[idx++];
```

## Probe / Calibration Sensor

The firmware supports a single probe input for tool length, surface touch-off, or bed leveling workflows.

Pin assignment:

- `PROBE` = `PG0` (active low, internal pull-up enabled)

Electrical behavior:

- Idle (not triggered): input reads high -> feedback `probe = 1`.
- Triggered (contact closed to ground): input reads low -> feedback `probe = 0`.

Integration details:

- Probe state is a dedicated 32-bit field appended after jog speed telemetry in the feedback packet.
- Motion planner / host can poll this value each cycle for edge detection (watch for transition 1 -> 0).
- The probe is polled (no interrupt) to keep logic simple; typical cycle time (10 ms feedback) suffices for manual or slow probing. For high-speed probing, reduce feedback interval.

Example host probe edge detection snippet:

```c
static uint32_t lastProbe = 1; // assume not triggered
void handle_feedback(const uint8_t *buf){
  const RemoraUdpHeader *hdr = (const RemoraUdpHeader*)buf;
  const uint8_t *pl = buf + sizeof(RemoraUdpHeader);
  const uint32_t *u = (const uint32_t*)pl;
  int idx = 0;
  idx += JOINTS; // jointFeedback
  idx += JOINTS; // processVariable
  uint32_t inputs    = u[idx++];
  uint32_t faultMask = u[idx++];
  uint32_t estop     = u[idx++];
  uint32_t jogSpeed[4];
  for(int a=0;a<4;++a) jogSpeed[a] = u[idx++];
  uint32_t jogTarget[4];
  for(int a=0;a<4;++a) jogTarget[a] = u[idx++];
  uint32_t jogDir[4];
  for(int a=0;a<4;++a) jogDir[a] = u[idx++];
  uint32_t probe = u[idx++];
  if (lastProbe == 1 && probe == 0) {
    // probe just triggered
  }
  lastProbe = probe;
}
```

Safety interactions:

- Probe reporting is suppressed only by hardware failure; E-Stop/fault do not mask the probe field (host may need last-known state during fault analysis).


## Flashing

Using OpenOCD (adjust interface if not ST-Link):

```bash
openocd -f interface/stlink.cfg -f target/stm32f4x.cfg \
  -c "program XCORE407I_FIRMWARE.bin 0x08000000 verify reset exit"
```

Or using `st-flash`:

```bash
st-flash --reset write XCORE407I_FIRMWARE.bin 0x8000000
```

### Flashing via USB DFU (Optional)

The onboard STM32F407 system bootloader supports USB DFU (Device Firmware Upgrade) over the USB Full-Speed (FS) port (PA11=USBDM, PA12=USBDP). This provides a tool-free method (no ST-Link) to program flash.

Steps:

1. Set BOOT0 pin HIGH (1). Ensure BOOT1 (if present or strapped internally) remains LOW (0).
2. Press RESET (or power cycle). The MCU enters the system memory bootloader and enumerates as a DFU device (VID/PID `0483:DF11`).
3. Flash the firmware using `dfu-util` or STM32CubeProgrammer.
4. Restore BOOT0 to LOW (0) and RESET again to run the newly flashed application from flash.

Example (Linux/macOS, using binary image):

```bash
dfu-util -a 0 -s 0x08000000:leave -D build/XCORE407I_FIRMWARE.bin
```

Helper script (auto-detects DFU device, optional retries):

```bash
./scripts/flash_dfu.sh build/XCORE407I_FIRMWARE.bin --retries 15 --wait 1
```

Notes:

- `-a 0` selects the flash DFU alt-setting; `:leave` triggers an automatic exit/reset from DFU after flashing.
- Ensure the file path matches your build directory (if you used a target-specific build path, adjust accordingly).
- If the device is not detected, check dmesg (Linux) or ensure a data-capable USB cable is used.
- CubeProgrammer (Windows/Linux GUI) can also program via DFU; select USB connection, refresh, then download the binary at `0x08000000`.
 - The helper script waits for enumeration and parses success text even if `dfu-util` returns a non-zero leave code on some hosts.

Primary vs Optional: ST-Link (SWD) remains the recommended primary development method (faster, offers debug). DFU is an optional field update path or fallback when a debug probe is unavailable.

Schematic Reference: The USB FS connector/data lines used for DFU appear in the schematic (`resources/schematic/xcore407i schematic/`) on pins PA11 (DM) and PA12 (DP). Confirm BOOT0 jumper location and that 1.5 kΩ pull-up circuitry is present/enabled as per the STM32F4 reference design.

## Network Configuration

Static IP is set in `lwip_port.c` (update as needed). Ensure your host is on the same subnet.

Default (example) configuration:

- IP: 192.168.2.50
- Netmask: 255.255.255.0
- Gateway: 192.168.2.1

## Remora UDP Protocol

Port: `27181`

Header (little endian):

```text
uint32_t magic  = 0x524D5241 ("RMRA")
uint32_t seq    = incrementing sequence
uint16_t length = payload bytes
uint16_t reserved = 0
```

Command Payload Layout (Tx Host -> MCU):

```text
int32_t  jointFreqCmd[JOINTS]
int32_t  setPoint[VARIABLES]
uint32_t jointEnable (bitmask)
uint32_t outputs (bitmask)
```

Feedback Payload Layout (MCU -> Host):

```text
int32_t  jointFeedback[JOINTS]
int32_t  processVariable[VARIABLES]
uint32_t inputs (bitmask)
uint32_t faultMask (bit0=X, bit1=Y, bit2=Z, bit3=A)
uint32_t estop (0 = normal, 1 = E-Stop latched)
```

The first valid command received establishes the unicast source (IP/port) used for all subsequent feedback packets. Broadcast is no longer used for feedback.

### Sequence Gap Detection

If an incoming sequence is not exactly `last+1` (and not the first packet), the internal gap counter increments. Retrieve via diagnostics API.

## Diagnostics

APIs:

- `const void *ethernetif_get_stats(void);` – Returns struct with: `rx_ok`, `rx_dropped`, `rx_alloc_fail`, `rx_errors`, `link_up_events`, `link_down_events`.
- `const struct remora_diag_stats *remora_get_diag(void);` – Returns: `last_rx_seq`, `seq_gap_events`.

(You can temporarily instrument prints or expose these over a debug interface.)

### UART Runtime Commands (USART3 115200 8N1)

Type a command followed by ENTER ("\n"):

| Command  | Action |
|----------|--------|
| `help`      | Lists all available commands. |
| `phy?`      | Prints current PHY address, ID, BCR/BSR, PHYSTS snapshot. |
| `phyid`     | Re-reads PHY ID registers and validates DP83848I OUI pattern. |
| `mdio?`     | Prints MDIO reliability statistics (rd/wr ok/fail/retry). |
| `mdioclr`   | Clears MDIO statistics counters. |
| `ethrst`    | Restarts auto-negotiation on the active PHY (alias to autoneg restart). |
| `ethloop`   | Executes internal PHY loopback test and reports PASS/FAIL. |
| `ethtest`   | Sends one debug broadcast frame (use packet capture to observe). |
| `board?`    | Prints compiled feature toggles (ETH/ULPI/NAND) and active TX_EN pin. |
| `ethforce`  | Force or release link speed/duplex (see below). |
| `status`    | Summarizes link state, PHY mode, forced/autoneg, MDIO + MAC RX counters. |
| `version?`  | Prints firmware semantic version and build metadata (date/time/git). |

Unknown commands echo a notice. Backspace editing supported. Parser is non-blocking (polled each main loop iteration).

#### Forcing Ethernet Speed / Duplex

The firmware supports manual override of PHY auto-negotiation for diagnostics:

```text
ethforce auto      # Re-enable autonegotiation (default behavior)
ethforce 100f      # Force 100 Mbps Full Duplex
ethforce 100h      # Force 100 Mbps Half Duplex
ethforce 10f       # Force 10 Mbps Full Duplex
ethforce 10h       # Force 10 Mbps Half Duplex
```

Implementation details:

- `ethforce <mode>` writes PHY Basic Control Register (BCR) disabling autoneg (clears bit12) and sets speed (bit13) + duplex (bit8) according to the selection.
- MAC `MACCR` speed/duplex bits are updated immediately to avoid a transient mismatch while link renegotiates.
- `status` reports `mode=FORCED(100M Full)` etc. while forced; otherwise `mode=AUTO`.
- After returning to `auto`, autoneg is restarted (`BCR` bit9 + bit12 set) and `forced` flags cleared.
- Useful for isolating switch autoneg issues, verifying deterministic latency at 100M full, or testing 10M fallback paths.

Example session:

```text
> ethforce 10f
[CMD][ETH] forced 10M FullDuplex
> status
[STATUS] link=1 phy=10M Full mode=FORCED(10M Full) mdio rd_ok=128 rd_fail=0 wr_ok=42 wr_fail=0 rx_ok=512 drop=0 alloc_fail=0 err=0 tx_ok=480 tx_err=0 up=1 down=0
> ethforce auto
[CMD][ETH] autoneg enabled
```text

#### Version Metadata

`version?` prints semantic version (compile-time macros `FW_VERSION_MAJOR/MINOR/PATCH`) and build info string (`__DATE__ __TIME__ git:<hash>`). The short git hash is auto-injected by CMake (falls back to `nogit` if not a git repo). You can still override components with `-DFW_VERSION_MAJOR=... -DFW_GIT_HASH=...` during configure if needed.

### Link Inactivity Watchdog

While link is reported up (carrier) and after the grace period, the firmware tracks receive activity:

1. Warn after 15 s of no RX frames: `[ETH][WARN] No RX frames for <ms> ms while link up`.
2. Restart autonegotiation after 30 s inactivity: `[ETH][ACT] Inactivity restart autoneg`.

This assists diagnosing silent-link conditions (e.g., switch port isolation or cable one-way faults). Activity timer resets on any received frame or link transition.

## Ethernet Hardware Notes

### DP83848I RMII Mapping (Validated)

REF_CLK=PA1, MDIO=PA2, CRS_DV=PA7, MDC=PC1, RXD0=PC4, RXD1=PC5, TXD0=PB12, TXD1=PB13, TX_EN=PB11 (default) or PG11 (when `USE_PG11_TXEN=ON`). PHY reset line not separately routed (RESET_N tied to NRST).

### Hardware Checksum Offload

Enable with `-DETH_HW_CHECKSUM=ON` (CMake). This sets `ETH_CHECKSUM_BY_HARDWARE` and disables software checksum generation/verification in `lwipopts.h` to avoid double work. Disable (default) if debugging packet integrity or using a non-offload MAC.

### PHY OUI Validation

On startup the code reads PHYIDR1/2 (registers 0x02/0x03). Expected DP83848I pattern: ID1=0x2000, (ID2 & 0xFFF0)=0x5C90. A mismatch prints a warning but does not halt execution.

### UART Command `phyid`

Use the new `phyid` command to reprint PHY ID registers and show whether they match the DP83848I mask.

### Quick Build Examples

Checksum on, PG11 TX_EN (default):

```bash
cmake -B build -S targets/TARGET_XCORE407I -DETH_HW_CHECKSUM=ON -DUSE_PG11_TXEN=ON
cmake --build build -j
```

Force PB11 TX_EN, checksum off:

```bash
cmake -B build -S targets/TARGET_XCORE407I -DUSE_PG11_TXEN=OFF -DETH_HW_CHECKSUM=OFF
cmake --build build -j
```

## Board Feature Toggles

Compile-time feature selection is exposed via preprocessor macros defined in `board_xcore407i.h`. Override them at configure time with `-D<NAME>=<0|1>`.

| Macro | Default | Purpose | Notes |
|-------|---------|---------|-------|
| `BOARD_ENABLE_ETH`  | 1 | Enable Ethernet RMII (DP83848I) initialization and networking stack. | Conflicts with ULPI on PB12/PB13. |
| `BOARD_ENABLE_ULPI` | 0 | Enable USB HS ULPI (USB3300) interface support. | Mutually exclusive with Ethernet (TXD0/TXD1). |
| `BOARD_ENABLE_NAND` | 0 | Enable NAND Flash (FSMC) pin/config stubs. | Conflicts with default ENA X/Y (PD0/PD1). |

If both `BOARD_ENABLE_ETH` and `BOARD_ENABLE_ULPI` are set to 1, the build fails with a compile-time `#error` due to PB12/PB13 contention.

`TX_EN` pin selection (RMII): defaults to `PB11`. Use PG11 if board variant wired accordingly:

```bash
cmake -DUSE_PG11_TXEN=ON ..
```

### Toggle Build Examples

Enable Ethernet + NAND, default TX_EN (PG11):

```bash
cmake -B build -S targets/TARGET_XCORE407I \
  -DBOARD_ENABLE_ETH=1 -DBOARD_ENABLE_NAND=1 -DBOARD_ENABLE_ULPI=0
cmake --build build -j
```

Disable Ethernet, enable ULPI (mutually exclusive):

```bash
cmake -B build -S targets/TARGET_XCORE407I \
  -DBOARD_ENABLE_ETH=0 -DBOARD_ENABLE_ULPI=1
cmake --build build -j
```

Force PB11 `TX_EN` and enable checksum offload together with feature toggles:

```bash
cmake -B build -S targets/TARGET_XCORE407I \
  -DUSE_PG11_TXEN=OFF -DETH_HW_CHECKSUM=ON -DBOARD_ENABLE_ETH=1
cmake --build build -j
```

### Runtime Inspection

Use the UART command `board?` to print currently compiled feature states and active `TX_EN` pin:

```text
[BOARD] ETH=1 ULPI=0 NAND=0 TX_EN=PG11
```

This reflects the macros compiled into the binary (not dynamic runtime switches).

## Final Pin Map

### Motion Axes (X=0, Y=1, Z=2, A=3)

| Axis | STEP Pin (Timer/AF)        | DIR Pin | ENA Pin | ALM Pin (EXTI) | Encoder CH1 | Encoder CH2 | Encoder Timer |
|------|---------------------------|---------|---------|----------------|-------------|-------------|---------------|
| X    | PB6 (TIM4_CH1 AF2)        | PB7     | PD0     | PE0 (EXTI0)    | PB4         | PB5         | TIM3          |
| Y    | PB8 (TIM4_CH3 AF2)        | PB9     | PD1     | PE1 (EXTI1)    | PA8         | PA9         | TIM1          |
| Z    | PA6 (TIM3_CH1 AF2)        | PB14    | PD2     | PE2 (EXTI2)    | PA15        | PB3         | TIM2          |
| A    | PC6 (TIM8_CH1 AF3)        | PC7     | PD3     | PE3 (EXTI3)    | (unused)    | (unused)    | (future)      |

ENA outputs are driven high (active) at initialization. ALM inputs are configured with pull-ups and falling-edge EXTI interrupts (modify to suit driver polarity). Add fault handling inside `HAL_GPIO_EXTI_Callback()`.

### Ethernet RMII

| Signal  | Pin  |
|---------|------|
| REF_CLK | PA1  |
| MDIO    | PA2  |
| CRS_DV  | PA7  |
| MDC     | PC1  |
| RXD0    | PC4  |
| RXD1    | PC5  |
| TX_EN   | PG11 |
| TXD0    | PB12 |
| TXD1    | PB13 |
| PHY_RST | PG13 |

Pins PB12/PB13 reserved for RMII TX (they conflict with potential ULPI D5/D6 if USB HS ULPI were added; Ethernet prioritized).

### Notes

- Alarm ISR currently stubs fault handling; integrate motion abort logic as needed.
- Add a fourth encoder later (avoid PA1/PA7 due to RMII). Consider TIM9 on PE5/PE6 if free.
- Feedback now includes a 32-bit `faultMask`. Any asserted bit indicates motion halt & drivers disabled.

### Fault Handling (ALM Inputs)

ALM pins (PE0..PE3) assert a fault (falling edge). On detection the firmware:

1. Sets a per-axis bit in a global fault mask (bit 0=X, 1=Y, 2=Z, 3=A).
2. Disables all step timers (TIM4, TIM3, TIM8) halting motion immediately.
3. Drives all ENA outputs low, removing drive power (configure hardware so low = disabled).
4. Leaves the system in a latched fault state until reset (future enhancement: remote clear command).

Accessor: `uint32_t motion_get_fault_mask(void);`

Integrate reporting into Remora feedback by extending the payload or mapping bits into an inputs field as needed.

## Manual Control & E-Stop

### Emergency Stop (E-Stop)

- Pin: PE4 (EXTI4), active low with internal pull-up.
- On assertion: sets `estop_active`, stops all step timers, drives ENA outputs low, halts motion. Latched until reset (no clear command yet).
- Accessor: `uint32_t motion_get_estop(void);` returns 1 if e-stop has occurred.

### Jog Inputs

| Function | Pin  | Active Level |
|----------|------|--------------|
| +X       | PF0  | Low          |
| -X       | PF1  | Low          |
| +Y       | PF2  | Low          |
| -Y       | PF3  | Low          |
| +Z       | PF4  | Low          |
| -Z       | PF5  | Low          |
| +A       | PF6  | Low          |
| -A       | PF7  | Low          |

Behavior:
 
1. Inputs use pull-ups; grounding a pin activates the jog.
2. Fixed jog speed: `JOG_FIXED_FREQ` (default 1000 steps/s) applied while input held.
3. Direction pin forced accordingly before enabling step timer channel; negative jog sets DIR low.
4. Jogging inhibited if any fault (`faultMask != 0`) or E-Stop active.
5. Multiple simultaneous jog inputs on the same axis undefined; first matching condition in polling order wins.

Integration:
 
- `jog_poll()` is invoked each main loop iteration. Adjust rate or move to a periodic timer if tighter control needed.
- For smoother jog motion (acceleration profiles) replace direct `stepgen_apply_command()` usage with a ramp planner.

Safety Precedence: E-Stop > Alarm Fault > Jog > Host Command.

### Extended UDP Opcodes

Optional 8-byte extension (two uint32_t little-endian) may follow the base command payload:

| Opcode | Name              | Value Meaning          |
|--------|-------------------|------------------------|
| 0      | NOP               | Ignored                |
| 1      | CLEAR_FAULTS      | Value ignored          |
| 2      | SET_JOG_SPEED     | Steps/s target         |
| 3      | SET_JOG_ACCEL     | Steps/s^2 acceleration |
| 4      | HOME_AXIS         | Axis index (0..3)      |
| 5      | ABORT_HOMING      | Value ignored          |

Behavior:
 
- CLEAR_FAULTS succeeds only if E-Stop not active. Returns to normal enabling (drivers re-enabled) but motion remains halted until host issues new freq commands or jog input.
- SET_JOG_SPEED & SET_JOG_ACCEL update internal parameters used by `jog_poll()` ramp logic.

### Homing

Homing sequence (per-axis): SEEK -> TRIGGERED -> BACKOFF -> SET_ZERO -> DONE.
Probe (active low) must remain triggered for a debounce window to finalize SEEK. A short reverse BACKOFF improves repeatability. Axis offsets are applied so reported encoder value becomes zero after SET_ZERO. Homed axes are indicated in `statusFlags` bits8-11; bit3 = homingActive. Jogging is inhibited during homing.

### Jog Debounce & Acceleration

- Debounce: Each jog input must be stable active for `JOG_DEBOUNCE_COUNT` polls (default 5) before it is considered asserted.
- Ramp: A global jog speed ramps toward configured target using `jog_accel` (default `JOG_ACCEL_DEFAULT`). Approximate update: `speed += accel/1000 * delta_ms`.
- Direction changes immediately update DIR pin; ramp continues toward target speed.
- Host can dynamically adjust speed/accel via opcodes without resetting motion.


## Timing

`sys_now()` provided by `sys_port.c` wraps `HAL_GetTick()`; ensure SysTick runs at 1 kHz (default HAL init).

## Extending

- Enable zero-copy by mapping DMA Rx buffers directly into custom `pbuf`s.
- Add step pulse scheduling / acceleration planner.
- Implement persistent configuration storage (Flash sector).

## Testing Procedure

1. Flash firmware.
2. Connect board Ethernet to LAN (ensure link LEDs active).
3. From host, `ping <board-ip>` (should respond if ICMP enabled in lwIP build).
4. Send a valid Remora command packet (structure above). Example using Python (pseudo-code) to set joint 0 frequency:

```python
import socket, struct
JOINTS=4; VARS=4
magic=0x524D5241; seq=1
jointFreq=[1000,0,0,0]
setPoint=[0]*VARS
jointEnable=1
outputs=0
payload=struct.pack('<'+('i'*JOINTS)+('i'*VARS)+'II', *jointFreq,*setPoint,jointEnable,outputs)
hdr=struct.pack('<IIHH', magic, seq, len(payload), 0)
s=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)
s.sendto(hdr+payload, ('192.168.2.50',27181))
# Receive feedback
data,_=s.recvfrom(512)
```

1. Inspect received feedback counts.
2. Send multiple packets with incrementing sequence; verify no gap events.

## License

Refer to upstream STM32CubeF4 licensing for HAL components. Project-specific additions released under your chosen terms.
