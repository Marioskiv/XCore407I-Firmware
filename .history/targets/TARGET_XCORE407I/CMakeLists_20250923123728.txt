cmake_minimum_required(VERSION 3.16)

# Configure cross toolchain & try-compile BEFORE project()
set(CMAKE_SYSTEM_NAME Generic)
set(CMAKE_SYSTEM_PROCESSOR arm)
set(CMAKE_TRY_COMPILE_TARGET_TYPE STATIC_LIBRARY)

# Prefer user toolchain if already in cache; otherwise find arm-none-eabi
if(NOT DEFINED CMAKE_C_COMPILER)
  find_program(ARM_GCC arm-none-eabi-gcc)
  if(NOT ARM_GCC)
    message(FATAL_ERROR "arm-none-eabi-gcc not found in PATH")
  endif()
  set(CMAKE_C_COMPILER ${ARM_GCC} CACHE FILEPATH "")
endif()
if(NOT DEFINED CMAKE_CXX_COMPILER)
  find_program(ARM_GPP arm-none-eabi-g++)
  if(NOT ARM_GPP)
    message(FATAL_ERROR "arm-none-eabi-g++ not found in PATH")
  endif()
  set(CMAKE_CXX_COMPILER ${ARM_GPP} CACHE FILEPATH "")
endif()
if(NOT DEFINED CMAKE_ASM_COMPILER)
  set(CMAKE_ASM_COMPILER ${CMAKE_C_COMPILER} CACHE FILEPATH "")
endif()

set(CMAKE_C_FLAGS_INIT "-mcpu=cortex-m4 -mthumb -mfpu=fpv4-sp-d16 -mfloat-abi=hard")
set(CMAKE_CXX_FLAGS_INIT "-mcpu=cortex-m4 -mthumb -mfpu=fpv4-sp-d16 -mfloat-abi=hard")
# NOTE: Do not set CMAKE_EXE_LINKER_FLAGS_INIT with --specs here; it's supplied exactly once via arm_flags

project(XCORE407I_FIRMWARE C CXX ASM)

# Ensure --specs=nosys.specs applied exactly once (avoid duplicate spec rename error)
if (CMAKE_EXE_LINKER_FLAGS MATCHES "nosys.specs")
  string(REGEX REPLACE "(^| )--specs=nosys\\.specs" "" CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS}")
endif()
set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} --specs=nosys.specs" CACHE STRING "" FORCE)

# Try to locate ARM embedded toolchain if not explicitly provided
if (NOT CMAKE_C_COMPILER MATCHES "arm-none-eabi-gcc")
  find_program(ARM_GCC arm-none-eabi-gcc)
  find_program(ARM_GPP arm-none-eabi-g++)
  find_program(ARM_ASM arm-none-eabi-gcc)
  if (ARM_GCC AND ARM_GPP)
    message(STATUS "Using ARM embedded toolchain: ${ARM_GCC}")
    set(CMAKE_C_COMPILER ${ARM_GCC} CACHE FILEPATH "" FORCE)
    set(CMAKE_CXX_COMPILER ${ARM_GPP} CACHE FILEPATH "" FORCE)
    set(CMAKE_ASM_COMPILER ${ARM_ASM} CACHE FILEPATH "" FORCE)
  else()
    message(FATAL_ERROR "arm-none-eabi-gcc toolchain not found. Please install gcc-arm-none-eabi.")
  endif()
endif()

# Locate objcopy for post-build binary generation
if (NOT CMAKE_OBJCOPY)
  find_program(CMAKE_OBJCOPY arm-none-eabi-objcopy)
  if (NOT CMAKE_OBJCOPY)
    find_program(CMAKE_OBJCOPY objcopy)
  endif()
endif()

set(CMAKE_C_STANDARD 11)
set(CMAKE_CXX_STANDARD 17)

# Absolute project root (two levels up from this file)
set(PROJECT_ROOT ${CMAKE_CURRENT_SOURCE_DIR}/../..)
get_filename_component(PROJECT_ROOT ${PROJECT_ROOT} REALPATH)
message(STATUS "Project root: ${PROJECT_ROOT}")

set(REMORA_SRC_DIR ${PROJECT_ROOT}/Remora-OS6/Firmware/FirmwareSource/Remora-OS6/TARGET_XCORE407I)
set(ST_ROOT        ${PROJECT_ROOT}/st)
set(CUBE_ROOT      ${ST_ROOT}/STM32CubeF4)
set(HAL_CONF_DIR   ${ST_ROOT}/hal_conf)

set(CUBE_CMSIS_INCLUDE ${CUBE_ROOT}/Drivers/CMSIS/Include)
set(CUBE_DEVICE_INCLUDE ${CUBE_ROOT}/Drivers/CMSIS/Device/ST/STM32F4xx/Include)
set(CUBE_HAL_INC ${CUBE_ROOT}/Drivers/STM32F4xx_HAL_Driver/Inc)

if (NOT EXISTS ${CUBE_HAL_INC}/stm32f4xx_hal.h)
  message(FATAL_ERROR "STM32CubeF4 HAL headers not found at ${CUBE_HAL_INC}. Expected submodule at ${CUBE_ROOT}. If missing: git submodule add https://github.com/STMicroelectronics/STM32CubeF4.git st/STM32CubeF4 && git submodule update --init --recursive")
endif()

add_executable(${PROJECT_NAME}
  startup_stm32f407xx.s
  ${REMORA_SRC_DIR}/main_xcore407i.cpp
  ${REMORA_SRC_DIR}/system_clock.c
  ${REMORA_SRC_DIR}/ethernet_init.c
  ${REMORA_SRC_DIR}/debug_uart.c
  ${REMORA_SRC_DIR}/version.c
  ${REMORA_SRC_DIR}/ulpi_init.c
  ${REMORA_SRC_DIR}/build_id.c
  ${REMORA_SRC_DIR}/remora_data.c
  ${REMORA_SRC_DIR}/drivers/drivers_init.c
  ${REMORA_SRC_DIR}/lwip/ethernetif.c
  ${REMORA_SRC_DIR}/lwip/lwip_port.c
  ${REMORA_SRC_DIR}/lwip/remora_udp.c
  ${REMORA_SRC_DIR}/stepgen.c
  ${REMORA_SRC_DIR}/motion_io.c
  ${REMORA_SRC_DIR}/jog.c
  ${REMORA_SRC_DIR}/homing.c
  ${REMORA_SRC_DIR}/config_store.c
  ${REMORA_SRC_DIR}/encoder.c
  ${REMORA_SRC_DIR}/auth.c
  ${REMORA_SRC_DIR}/board_motion_gpio.c
  ${PROJECT_ROOT}/src/net/udp_echo.c
  ${CUBE_ROOT}/Drivers/CMSIS/Device/ST/STM32F4xx/Source/Templates/system_stm32f4xx.c
  syscalls.c
)

target_include_directories(${PROJECT_NAME} PRIVATE
  ${PROJECT_ROOT}/Remora-OS6/Firmware/FirmwareSource/Remora-OS6
  ${REMORA_SRC_DIR}
  ${REMORA_SRC_DIR}/lwip
  ${PROJECT_ROOT}/src/net
  ${HAL_CONF_DIR}
  ${CUBE_CMSIS_INCLUDE}
  ${CUBE_DEVICE_INCLUDE}
  ${CUBE_HAL_INC}
  ${CUBE_ROOT}/Middlewares/Third_Party/LwIP/src/include
  ${CMAKE_CURRENT_SOURCE_DIR}/lwip_port
)

# HAL sources
set(HAL_SRC_DIR ${CUBE_ROOT}/Drivers/STM32F4xx_HAL_Driver/Src)
set(HAL_SOURCES
  ${HAL_SRC_DIR}/stm32f4xx_hal.c
  ${HAL_SRC_DIR}/stm32f4xx_hal_rcc.c
  ${HAL_SRC_DIR}/stm32f4xx_hal_rcc_ex.c
  ${HAL_SRC_DIR}/stm32f4xx_hal_gpio.c
  ${HAL_SRC_DIR}/stm32f4xx_hal_cortex.c
  ${HAL_SRC_DIR}/stm32f4xx_hal_pwr.c
  ${HAL_SRC_DIR}/stm32f4xx_hal_pwr_ex.c
  ${HAL_SRC_DIR}/stm32f4xx_hal_flash.c
  ${HAL_SRC_DIR}/stm32f4xx_hal_flash_ex.c
  ${HAL_SRC_DIR}/stm32f4xx_hal_dma.c
  ${HAL_SRC_DIR}/stm32f4xx_hal_eth.c
  ${HAL_SRC_DIR}/stm32f4xx_hal_tim.c
  ${HAL_SRC_DIR}/stm32f4xx_hal_tim_ex.c
  ${HAL_SRC_DIR}/stm32f4xx_hal_exti.c
  ${HAL_SRC_DIR}/stm32f4xx_hal_uart.c
)

target_sources(${PROJECT_NAME} PRIVATE ${HAL_SOURCES})

# Optional abstract driver layer (pin / qei)
option(USE_ABSTRACT_DRIVERS "Enable abstract pin & QEI drivers (working Ethernet profile default)" ON)
option(ENABLE_QEI_DIAG "Enable QEI diagnostic helper (requires USE_ABSTRACT_DRIVERS)" ON)
if (USE_ABSTRACT_DRIVERS)
  message(STATUS "Abstract drivers enabled (pin, qei)")
  target_sources(${PROJECT_NAME} PRIVATE
    ${REMORA_SRC_DIR}/drivers/pin/pin.cpp
    ${REMORA_SRC_DIR}/drivers/qei/qeiDriver.cpp
    $<$<BOOL:${ENABLE_QEI_DIAG}>:${REMORA_SRC_DIR}/qei_diag.c>
  )
  target_include_directories(${PROJECT_NAME} PRIVATE
    ${REMORA_SRC_DIR}/drivers/pin
    ${REMORA_SRC_DIR}/drivers/qei
  )
  target_compile_definitions(${PROJECT_NAME} PRIVATE USE_ABSTRACT_DRIVERS=1)
  if(ENABLE_QEI_DIAG)
    message(STATUS "QEI diagnostic enabled")
    target_compile_definitions(${PROJECT_NAME} PRIVATE ENABLE_QEI_DIAG=1)
  else()
    target_compile_definitions(${PROJECT_NAME} PRIVATE ENABLE_QEI_DIAG=0)
  endif()
else()
  target_compile_definitions(${PROJECT_NAME} PRIVATE USE_ABSTRACT_DRIVERS=0)
endif()

# Common optimization & warning flags (arch/float already in initial flags)
set(COMMON_NONARCH_FLAGS
  -O2
  -ffunction-sections
  -fdata-sections
  -fno-unwind-tables
  -fno-asynchronous-unwind-tables
  -Wall
  -Wextra
)

# Interface target to propagate identical compile & link flags to all consumers
add_library(arm_flags INTERFACE)
option(REMORA_STRICT "Treat warnings as errors" ON)
target_compile_options(arm_flags INTERFACE
  ${COMMON_NONARCH_FLAGS}
  -mcpu=cortex-m4
  -mthumb
  -mfpu=fpv4-sp-d16
  -mfloat-abi=hard
)

# Apply stricter pedantic flags only to our firmware target (exclude 3rd party libs)
if(REMORA_STRICT)
  target_compile_options(${PROJECT_NAME} PRIVATE -Werror)
endif()
target_compile_options(${PROJECT_NAME} PRIVATE -Wshadow -Wimplicit-fallthrough)
target_link_options(arm_flags INTERFACE
  -mcpu=cortex-m4
  -mthumb
  -mfpu=fpv4-sp-d16
  -mfloat-abi=hard
  -Wl,--gc-sections
  -Wl,--print-memory-usage
)

target_link_libraries(${PROJECT_NAME} PRIVATE arm_flags)
target_compile_options(${PROJECT_NAME} PRIVATE $<$<COMPILE_LANGUAGE:CXX>:-fno-exceptions -fno-rtti>)
option(USE_PG11_TXEN "Use PG11 as RMII TX_EN (else PB11)" ON)
option(ETH_HW_CHECKSUM "Enable MAC hardware checksum offload" OFF)
option(DFU_TRIM_BIN "Produce trimmed DFU binary without padding gaps" ON)
option(ETH_LEGACY_DESC_IN_CCM "Place ETH DMA descriptors in CCM section (legacy experimental)" OFF)
option(ETH_CLEAR_DESC_PTRS_POST_INIT "Clear heth.Init descriptor pointers after HAL init (legacy behavior)" OFF)
option(ETH_DISABLE_PHY_SCAN "Skip dynamic PHY scan and use fixed PHY_ADDRESS" OFF)

target_compile_definitions(${PROJECT_NAME} PRIVATE STM32F407xx USE_HAL_DRIVER)

# Board feature toggles (previously only in header defaults). Expose as CMake options
option(BOARD_ENABLE_ETH "Enable Ethernet RMII (DP83848I)" ON)
option(BOARD_ENABLE_ULPI "Enable USB HS ULPI (conflicts with Ethernet pins PB12/PB13)" OFF)
option(BOARD_ENABLE_NAND "Enable NAND Flash interface" OFF)

if(BOARD_ENABLE_ETH)
  target_compile_definitions(${PROJECT_NAME} PRIVATE BOARD_ENABLE_ETH=1)
else()
  target_compile_definitions(${PROJECT_NAME} PRIVATE BOARD_ENABLE_ETH=0)
endif()
if(BOARD_ENABLE_ULPI)
  target_compile_definitions(${PROJECT_NAME} PRIVATE BOARD_ENABLE_ULPI=1)
else()
  target_compile_definitions(${PROJECT_NAME} PRIVATE BOARD_ENABLE_ULPI=0)
endif()
if(BOARD_ENABLE_NAND)
  target_compile_definitions(${PROJECT_NAME} PRIVATE BOARD_ENABLE_NAND=1)
else()
  target_compile_definitions(${PROJECT_NAME} PRIVATE BOARD_ENABLE_NAND=0)
endif()

if(ETH_LEGACY_DESC_IN_CCM)
  target_compile_definitions(${PROJECT_NAME} PRIVATE ETH_LEGACY_DESC_IN_CCM=1)
endif()
if(ETH_CLEAR_DESC_PTRS_POST_INIT)
  target_compile_definitions(${PROJECT_NAME} PRIVATE ETH_CLEAR_DESC_PTRS_POST_INIT=1)
endif()
if(ETH_DISABLE_PHY_SCAN)
  target_compile_definitions(${PROJECT_NAME} PRIVATE ETH_DISABLE_PHY_SCAN=1)
endif()

# Auto-detect git short hash for firmware build info (fallback to nogit)
find_package(Git QUIET)
set(FW_GIT_HASH "nogit")
if(GIT_FOUND)
  execute_process(
    COMMAND ${GIT_EXECUTABLE} rev-parse --short HEAD
    WORKING_DIRECTORY ${PROJECT_ROOT}
    OUTPUT_VARIABLE GIT_HASH_OUT
    OUTPUT_STRIP_TRAILING_WHITESPACE
    ERROR_QUIET)
  if(GIT_HASH_OUT MATCHES "^[0-9a-fA-F]+$")
    set(FW_GIT_HASH ${GIT_HASH_OUT})
  endif()
endif()
message(STATUS "Firmware git hash: ${FW_GIT_HASH}")
target_compile_definitions(${PROJECT_NAME} PRIVATE FW_GIT_HASH="${FW_GIT_HASH}")
if (USE_PG11_TXEN)
  target_compile_definitions(${PROJECT_NAME} PRIVATE USE_PG11_TXEN=1)
else()
  target_compile_definitions(${PROJECT_NAME} PRIVATE USE_PG11_TXEN=0)
endif()
if (ETH_HW_CHECKSUM)
  target_compile_definitions(${PROJECT_NAME} PRIVATE ETH_HW_CHECKSUM=1)
else()
  target_compile_definitions(${PROJECT_NAME} PRIVATE ETH_HW_CHECKSUM=0)
endif()
target_compile_definitions(${PROJECT_NAME} PRIVATE DEBUG_UART_ENABLE=1)
set(CMAKE_ASM_FLAGS "${CMAKE_ASM_FLAGS} -mcpu=cortex-m4 -mthumb")

# Linker script
set(LINKER_SCRIPT ${CMAKE_CURRENT_SOURCE_DIR}/STM32F407IGT_FLASH.ld)

# Linker options
if (NOT CMAKE_OBJCOPY)
  message(WARNING "objcopy not found; .bin generation will be skipped")
endif()

target_link_options(${PROJECT_NAME} PRIVATE -T${LINKER_SCRIPT} -nostartfiles -Wl,-Map=${PROJECT_NAME}.map)

# Post-build binary
if (CMAKE_OBJCOPY)
  add_custom_command(TARGET ${PROJECT_NAME} POST_BUILD
    COMMAND ${CMAKE_OBJCOPY} -O binary ${PROJECT_NAME} ${PROJECT_NAME}.bin
    COMMENT "Generating binary file"
  )
  if(DFU_TRIM_BIN)
    add_custom_command(TARGET ${PROJECT_NAME} POST_BUILD
      COMMAND ${CMAKE_OBJCOPY} -O binary --remove-section .ccm_data --remove-section ._user_heap_stack ${PROJECT_NAME} ${PROJECT_NAME}_flash.bin
      COMMENT "Generating trimmed DFU binary (${PROJECT_NAME}_flash.bin)"
    )
  endif()
endif()

# --- Convenience targets: DFU flash & verify ---
find_program(DFU_UTIL dfu-util)
if(DFU_UTIL)
  add_custom_target(flash_dfu
    COMMAND ${CMAKE_COMMAND} -E echo "[flash_dfu] Invoking helper script"
    COMMAND ${CMAKE_COMMAND} -E env FW_BIN=${CMAKE_BINARY_DIR}/${PROJECT_NAME}.bin bash ${PROJECT_ROOT}/scripts/flash_dfu.sh ${CMAKE_BINARY_DIR}/${PROJECT_NAME}.bin
    DEPENDS ${PROJECT_NAME}
    COMMENT "Flashing ${PROJECT_NAME}.bin to 0x08000000 via dfu-util"
  )

  add_custom_target(verify_flash
    COMMAND ${CMAKE_COMMAND} -E echo "[verify_flash] Starting readback"
    COMMAND ${CMAKE_COMMAND} -E env BIN_SIZE=$<SHELL_PATH:$<TARGET_FILE:${PROJECT_NAME}>>
    COMMAND sh -c "SIZE=\`stat -c%s ${CMAKE_BINARY_DIR}/${PROJECT_NAME}.bin\`; echo '[verify_flash] SIZE='\"$SIZE\"; dfu-util -a 0 -s 0x08000000:$SIZE -U readback.bin || true"
    COMMAND sh -c "cmp -s ${CMAKE_BINARY_DIR}/${PROJECT_NAME}.bin readback.bin && echo '[verify_flash] Match OK' || echo '[verify_flash] WARNING: Difference detected'"
    DEPENDS ${PROJECT_NAME}
    COMMENT "Verifying on-device flash matches built binary"
  )
else()
  message(STATUS "dfu-util not found: flash_dfu / verify_flash targets disabled")
endif()

# --- lwIP (Cube provided) minimal subset ---
set(LWIP_ROOT ${CUBE_ROOT}/Middlewares/Third_Party/LwIP)
if (NOT EXISTS ${LWIP_ROOT}/src/core/init.c)
  message(FATAL_ERROR "Expected lwIP sources under ${LWIP_ROOT}. Ensure Cube repo has Middlewares/Third_Party/LwIP")
endif()

set(LWIP_CORE_SRC
  ${LWIP_ROOT}/src/core/init.c
  ${LWIP_ROOT}/src/core/mem.c
  ${LWIP_ROOT}/src/core/memp.c
  ${LWIP_ROOT}/src/core/netif.c
  ${LWIP_ROOT}/src/core/pbuf.c
  ${LWIP_ROOT}/src/core/timeouts.c
  ${LWIP_ROOT}/src/core/def.c
  ${LWIP_ROOT}/src/core/ip.c
  ${LWIP_ROOT}/src/core/inet_chksum.c
  # autoip omitted
  ${LWIP_ROOT}/src/core/ipv4/icmp.c
  ${LWIP_ROOT}/src/core/ipv4/ip4_addr.c
  ${LWIP_ROOT}/src/core/ipv4/ip4.c
  ${LWIP_ROOT}/src/core/ipv4/ip4_frag.c
  ${LWIP_ROOT}/src/core/ipv4/etharp.c
  ${LWIP_ROOT}/src/core/udp.c
  ${LWIP_ROOT}/src/netif/ethernet.c
  ${LWIP_ROOT}/src/core/ipv4/dhcp.c
)

add_library(lwipcore STATIC ${LWIP_CORE_SRC} lwip_port/sys_arch.c)
target_include_directories(lwipcore PUBLIC
  ${LWIP_ROOT}/src/include
  ${CMAKE_CURRENT_SOURCE_DIR}/lwip_port
)
target_compile_definitions(lwipcore PUBLIC NO_SYS=1 LWIP_TIMEVAL_PRIVATE=1)
if (ETH_HW_CHECKSUM)
  target_compile_definitions(lwipcore PUBLIC ETH_HW_CHECKSUM=1)
endif()

target_link_libraries(${PROJECT_NAME} PRIVATE lwipcore)
target_link_libraries(lwipcore PUBLIC arm_flags)
