# TARGET_XCORE407I (STM32F407IGT6)

Preliminary target support for custom XCore407I board used as a LinuxCNC hardware interface.

## Clocking
- HSE 8 MHz, LSE 32.768 kHz
- PLL: 168 MHz SYSCLK, 48 MHz for USB (PLLQ=7)

## Peripherals
- Ethernet RMII (DP83848, PHY addr 0x01) – IMPLEMENTED (MAC + RMII GPIO + PHY reset)
- lwIP (NO_SYS raw API) with Remora UDP protocol (port 27181) – IMPLEMENTED
- USB HS with ULPI (USB3300) – skeleton only (pin conflict with RMII PB12/PB13 to validate)
- FSMC (NAND K9F1G08U0C) – skeleton only
- GPIO: Step/Dir (4 axes), limit switches, LEDs, resets (placeholders)
- Optional encoder (TIMx in encoder mode) – planned

## Files
- `board_xcore407i.h` – Pin mapping summary
- `stm32f4xx_hal_conf.h` – HAL module enables
- `system_clock.c` – 168 MHz clock init
- `ethernet_init.c` – ETH handle init (RMII configured, PHY reset pulse)
- `lwip/` – Minimal lwIP port (`lwipopts.h`, `ethernetif.c`, `lwip_port.c`, `remora_udp.c`)
- `ulpi_usb_init.c` – USB HS ULPI init (GPIO + reset TODO)
- `nand_fsmc.c` – NAND FSMC skeleton
- `motion_pins.h` – Placeholder motion IO mapping

## Current Status / TODO
Completed:
- System clock @168 MHz in `SystemInit`
- Ethernet RMII GPIO + PHY reset (PG13)
- HAL ETH init (RMII mode, autonegotiation)
- Minimal lwIP bring-up with static IP and Remora UDP handler

Pending / Planned:
- Validate/resolve ULPI vs RMII PB12/PB13 conflict if USB HS needed simultaneously
- Add link status monitoring and LED indication
- Expand lwIP config (DHCP optional, statistics, mutex protection if RTOS added)
- Implement NAND operations (Read ID/Page/Program/Erase)
- Step/Dir timing and encoder timer configuration
- (DONE) LinuxCNC Remora UDP packet handler (basic commands/feedback)
- Power management and watchdog integration for network fault recovery

## Network Configuration
DHCP first; static fallback after ~5 s timeout (see `lwip_port.c`):
- Fallback IP: `192.168.2.50`
- Netmask: `255.255.255.0`
- Gateway: `192.168.2.1`

Services:
- UDP Echo: port `5005` (stateless echo of payload)
- Remora UDP: port `27181` (feedback after first valid packet)

USB:
- Enumerates as CDC ACM with VID:PID `0483:5740` (ST VCP)

### Remora UDP Packet Format (Current Minimal)
All packets begin with a 12-byte header:
```
Offset  Size  Field
0       4     Magic 'RMRA' (0x52 0x4D 0x52 0x41)
4       4     Sequence (uint32)
8       2     Payload length (uint16)
10      2     Reserved (0)
```

RX Payload (Host -> Board):
```
int32_t jointFreqCmd[JOINTS];        // motion frequency commands
float   setPoint[VARIABLES];         // servo/temperature/PWM setpoints
uint8_t jointEnable;                 // bitmask enables
uint16_t outputs;                    // digital outputs bitmap
```

TX Payload (Board -> Host):
```
int32_t jointFeedback[JOINTS];
float   processVariable[VARIABLES];
uint16_t inputs;                     // digital inputs bitmap
```

### Test Instructions (LinuxCNC / Host)
1. Connect board Ethernet to a host on `192.168.50.0/24`.
2. Craft a minimal command packet (example using Python):
```python
import socket, struct
JOINTS=4
VARIABLES=4
magic = 0x524D5241
seq = 1
jointFreqCmd=[1000,1000,0,0]
setPoint=[0.0,0.0,0.0,0.0]
jointEnable=0x0F
outputs=0
payload = struct.pack('<'+'i'*JOINTS+'f'*VARIABLES+'B'+'H', *jointFreqCmd, *setPoint, jointEnable, outputs)
hdr = struct.pack('<IIHH', magic, seq, len(payload), 0)
pkt = hdr+payload
s=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)
s.sendto(pkt, ('192.168.2.50',27181))
data,_=s.recvfrom(1500)
print('RX bytes', len(data))
print('Header', struct.unpack('<IIHH', data[:12]))
print('Feedback lens',(len(data)-12))
```
3. Observe board UART logs for `[UDP RX]` and `[UDP TX]` lines.
4. Adjust `jointFreqCmd` and resend to validate frequency command reception.

If no response:
- Confirm UDP not blocked by host firewall.
- Validate link LEDs and autonegotiation.
- Ensure magic field matches `RMRA`.
- Check sequence increments and board printouts.

## Design Notes
- `NO_SYS=1` chosen to keep stack cooperative; `lwip_port_poll()` is called in the main loop.
- Frames are copied into temporary buffers (simpler, can be optimized later with zero-copy descriptors).
- Hardware checksum is left enabled in HAL; lwIP config keeps checksum generation/checking for IP/UDP.

## Motion Control Integration (Prototype)
Step Generation (current mapping):
- Axis0 (X): STEP PB6 (TIM4_CH1), DIR PB7
- Axis1 (Y): STEP PB8 (TIM4_CH3), DIR PB9
- Axis2 (Z): STEP PA6 (TIM3_CH1), DIR PB14 (moved off PA7 to remove RMII CRS_DV conflict)
- Axis3 (A): STEP PC6 (TIM8_CH1), DIR PC7 (optional second channel TIM8_CH2 reserved)
- Timers: TIM4 drives Axes 0 & 1 (separate channels), TIM3 Axis2, TIM8 Axis3
- Step timer base clock prescaled to 1 MHz; applied frequency f -> ARR = (1e6 / (2*f)) for toggle output
- If joint disabled or frequency <= 0 the channel output is halted (timer channel disabled)

Encoders (remapped to eliminate RMII and STEP/DIR conflicts):
- Enc0: TIM3_CH1 PB4, TIM3_CH2 PB5
- Enc1: TIM1_CH1 PA8, TIM1_CH2 PA9
- Enc2: TIM2_CH1 PA15, TIM2_CH2 PB3
- Enc3: (not wired / placeholder) always returns 0
- Each timer configured in encoder mode, 16‑bit counters read before assembling TX feedback.

PHY Link Monitoring:
- `ETH_LinkUp()` polls PHY BSR; link UP/DOWN transitions logged.

Limitations / To-Do:
- No acceleration / trajectory planning (direct frequency drive only)
- Encoder rollover extension (software 32-bit accumulate) not implemented
- Shared TIM4 means full timer base is common—channel gating prevents pulses per-axis but advanced per-axis prescalers not available; future option: dedicate another timer if higher resolution needed
- Axis3 encoder unimplemented; add mapping only if hardware provides signals

## Next Optimization Ideas
- Add zero-copy TX/RX using DMA descriptor pbuf integration.
- Integrate link state change interrupt (EXTI or periodic PHY register poll).
- Extend Remora UDP command parser (add CRC, error codes, larger variable sets, fragmentation if needed).

This is an initial scaffold; many functions are stubbed and require completion. Pin mappings reflect the latest conflict-free assignment; update `board_xcore407i.h` if hardware routing differs.
