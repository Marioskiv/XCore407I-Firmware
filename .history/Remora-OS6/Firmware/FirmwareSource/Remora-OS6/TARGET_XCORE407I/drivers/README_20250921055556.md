# Abstract Driver Layer (Optional)

This directory introduces optional abstraction layers for the XCORE407I target.

## Components

* `pin/`: Minimal GPIO wrapper (`pin_t`, mode helpers, read/write/toggle) to decouple high level motion / homing / jog logic from raw HAL calls.
* `qei/`: Lightweight quadrature encoder interface (`qei_t`) wrapping a TIM peripheral in encoder mode with rollover accumulation.
* `drivers_init.*`: Aggregator for future driver initialization (currently calls `encoder_init()`).
* `comms/`: Placeholder skeleton for a future Remora communications abstraction (stats, send/poll functions).

## Enabling

Enable via CMake option:

```cmake
```cmake
DUSE_ABSTRACT_DRIVERS=ON
```

## Design goals

1. Keep zero overhead when disabled (no includes, no added code size).
2. Provide a convergence path with other targets (e.g. `TARGET_STM32F4`) that already use driver layering.
3. Avoid intrusive refactors initially – integration can be incremental by selectively migrating modules to the abstraction.

## Integration suggestions

* Replace direct `HAL_GPIO_WritePin()` calls in `stepgen.c`, `homing.c`, `jog.c` with `pin_write()` after creating `pin_t` handles in an init function.
* Bridge existing `encoder.c` to call into `qei_get_position()` if you want unified logic; or gradually retire local encoder counting.
* Add future `comms/` layer mirroring `RemoraComms.*` if a standardized host protocol wrapper (beyond UDP) is desired.

## Limitations / Next Steps

* `qeiDriver.cpp` assumes TIM encoder channel GPIO configuration (AF, pull, speed) is already performed externally.
* No dynamic allocation – all state provided by caller.
* Does not currently expose velocity or index pulse handling.

## Extending

* Add `pin_mode_alternate()` helper to unify AF config for timers / encoders.
* Provide `qei_config_channels(tim, invertA, invertB)` for polarity adjustments.
* Introduce abstraction for step pulse generation hardware selection if multiple timers are supported.
* Flesh out `comms/` layer to encapsulate UDP framing & transport; expose uniform API across targets.

## QEI Velocity API

Velocity estimation has been added (simple discrete derivative):

```c
int qei_init(qei_t *q, TIM_TypeDef *tim, uint32_t period, int32_t start_position, int start_ms);
int32_t qei_update_velocity(qei_t *q, int now_ms); // returns counts/sec
int32_t qei_get_velocity(const qei_t *q);
```

Call `qei_update_velocity()` at your control loop period (e.g. every 1 ms or 10 ms). It samples position internally and computes `velocity_cps = delta_counts * 1000 / dt_ms`.

Limitations:
 
* Integer math only; for high resolution or sub-ms loops consider fixed-point scaling.
* No filtering (apply your own moving average if needed).
* Wrap detection increments `wraps` (debug counter) but does not yet adjust velocity smoothing.

## Maintainer Notes

* Keep inline functions small to encourage compiler inlining.
* If warning levels increase, ensure structures are fully initialized to satisfy `-Wmissing-field-initializers` under `-Werror`.
